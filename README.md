### Краткий справочник по TypeScript

 Сделан при помощи DeepSeek, на основе этой статьи: **["Работа с индексными членами в TypeScript"](https://habr.com/ru/articles/938860/)**.
 
---

### 1. Object, Array, Tuple
- **`object`**: Тип только для объектов (не примитивов). Более строгий, чем `Object`.
- **`Array<Type>` / `Type[]`**: Типизированный массив.
- **`Tuple [T0, T1, …]`**: Массив с фиксированной длиной и заданными типами для каждого индекса. Позволяет добавлять элементы только совместимых типов.

### 2. Объектные типы с индексными членами
- **Индексная сигнатура** `{ [key: string]: Type }`: Позволяет определять объекты с динамическими ключами.
- **Строгая проверка (`--noUncheckedIndexedAccess`)**: Требует проверки существования динамического свойства перед доступом.
- **Операторы `?.` (optional chaining) и `!.` (non-null assertion)**:
    - `?.` безопасно обращается к свойствам/методам, возвращая `undefined` если левая часть `null/undefined`.
    - `!.` утверждает, что значение не `null/undefined` (отключает проверку компилятора).

### 3. `keyof`, Lookup Types, Mapped Types
- **`keyof T`**: Создает union-тип из всех ключей типа `T`.
- **Lookup Types `T[K]`**: Получает тип свойства `K` из типа `T`.
- **Mapped Types `{ [K in Keys]: Type }`**: Создает новый тип путем итерации по ключам.
    - **Префиксы `+` и `-`**: Управляют модификаторами (`readonly`, `?`) в Mapped Types (`+` - добавить, `-` - убрать).

### 4. Условные типы
- **`T extends U ? T1 : T2`**: Тип, зависящий от условия. Аналогичен тернарному оператору.
- **Distributive Conditional Types**: Если `T` - это union, условный тип применяется к каждому элементу по отдельности.
- **`infer`**: Позволяет объявлять переменную типа внутри условного типа для вывода типа из другого типа (например, из параметров функции, из типа элемента массива).

### 5. Встроенные утилиты (Utility Types)
- **`Partial<T>`**: Все свойства `T` становятся необязательными.
- **`Required<T>`**: Все свойства `T` становятся обязательными.
- **`Readonly<T>`**: Все свойства `T` только для чтения.
- **`Pick<T, K>`**: Выбирает из `T` только свойства `K`.
- **`Record<K, T>`**: Создает тип с ключами `K` и значениями `T`.
- **`Exclude<T, U>`**: Исключает из `T` типы, assignable к `U`.
- **`Extract<T, U>`**: Извлекает из `T` типы, assignable к `U`.
- **`Omit<T, K>`**: Исключает свойства `K` из типа `T`.
- **`ReturnType<T>`**: Получает тип возвращаемого значения функции.
- **`Parameters<T>`**: Получает типы параметров функции в виде кортежа.
- **`Awaited<T>`**: Рекурсивно извлекает тип из `Promise`.

### 6. Модификатор `override`
- Позволяет явно пометить метод, который переопределяет метод родительского класса.
- **Флаг `--noImplicitOverride`**: Запрещает неявное переопределение (требует ключевого слова `override`).

---

### **Ключевые концепции для запоминания:**

1.  **Структуры данных:** `object` (строгий), `Array`, `Tuple` (фиксированная структура).
2.  **Динамические ключи:** Индексная сигнатура + используйте `--noUncheckedIndexedAccess` для безопасности.
3.  **Безопасный доступ:** `?.` для опционального chaining, `!.` для утверждения non-null.
4.  **Манипуляции с типами:**
    -   **`keyof`**: Получить ключи.
    -   **`T[K]`**: Получить тип свойства.
    -   **Mapped Types**: Создать тип на основе другого (`[K in keyof T]`).
    -   **Условные типы**: Логика для типов (`extends ? :`).
    -   **`infer`**: Вывод типов внутри условных типов.
5.  **Встроенные утилиты:** Знать основные (`Partial`, `Pick`, `Omit`, `ReturnType` и т.д.).
6.  **`override`:** Всегда используйте с `--noImplicitOverride` для надежного наследования.
